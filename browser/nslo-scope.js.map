{"version":3,"file":"nslo-scope.js","names":[],"mappings":"","sources":["nslo-scope.js"],"sourcesContent":["!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.Scope=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nfunction apply(scope,queue) {'use strict';\n\tif(queue) for (var i = 0; i < queue.length; i++) queue[i](scope);\n}\n/**\n * Creates a new Scope\n * @module nslo-scope\n */\nfunction Scope (queue, children, watch) {'use strict';\n\tif(!this) return new Scope(queue, children, watch);\n\tif(!queue) queue = [];\n\tif(!children) children = [];\n\tif(!watch) watch = {};\n\t/**\n\t * add a watcher to the scope\n\t * @param {string|function} path - path to watch or watch function\n\t * @param {function} [fn] - watch function if path was provided\n\t * @returns {function} unwatch - function to remove watcher\n\t **/\n\tthis.$watch = function(path, fn) {\n\t\tif(fn) (watch[path] || (watch[path] = [])).push(fn);\n\t\telse fn = path;\n\t\tqueue.push(fn);\n\t\treturn function() {\n\t\t\tvar index = -1;\n\t\t\tif(typeof path !== 'function') {\n\t\t\t\tindex = watch[path].indexOf(fn);\n\t\t\t\tif(index > -1) watch[path].splice(index, 1);\n\t\t\t}\n\t\t\tindex = queue.indexOf(fn);\n\t\t\tif(index > -1) queue.splice(index, 1);\n\t\t};\n\t};\n\t/**\n\t * Run all watchers for this scope and child scopes\n\t * @param {string} [path] - watcher path to run\n\t **/\n\tthis.$apply = function (path) {\n\t\tif(!path) apply(this, queue);\n\t\telse apply(this,watch[path]);\n\t\tfor (var i = 0; i < children.length; i++) children[i].$apply(path);\n\t};\n\t/**\n\t * creates a new child Scope\n\t * @returns {Scope} childScope\n\t **/\n\tthis.$new = function() {\n\t\tfunction ChildScope() {Scope.call(this);}\n\t\tChildScope.prototype = this;\n\t\tvar child = new ChildScope();\n\t\treturn children.push(child),child;\n\t};\n}\nmodule.exports = Scope;\n},{}]},{},[1])(1)\n});"],"sourceRoot":"/source/"}